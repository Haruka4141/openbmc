diff -Naur linux_old/drivers/soc/aspeed/aspeed-espi-ctrl.h linux/drivers/soc/aspeed/aspeed-espi-ctrl.h
--- linux_old/drivers/soc/aspeed/aspeed-espi-ctrl.h	2023-03-09 17:30:45.169942000 +0800
+++ linux/drivers/soc/aspeed/aspeed-espi-ctrl.h	2023-03-08 17:55:31.000000000 +0800
@@ -34,6 +34,8 @@
 
 /* eSPI register offset */
 #define ESPI_CTRL		0x000
+#define   ESPI_CTRL_SW_RESET			GENMASK(31, 24)
+#define   ESPI_HW_RESET				BIT(31)
 #define   ESPI_CTRL_OOB_RX_SW_RST		BIT(28)
 #define   ESPI_CTRL_FLASH_TX_DMA_EN		BIT(23)
 #define   ESPI_CTRL_FLASH_RX_DMA_EN		BIT(22)
@@ -46,6 +48,7 @@
 #define   ESPI_CTRL_FLASH_SW_MODE_SHIFT		10
 #define   ESPI_CTRL_PERIF_PC_RX_DMA_EN		BIT(16)
 #define   ESPI_CTRL_FLASH_SW_RDY		BIT(7)
+#define   ESPI_CTRL_OOB_CHRDY			BIT(4)
 #define   ESPI_CTRL_OOB_SW_RDY			BIT(4)
 #define   ESPI_CTRL_VW_SW_RDY			BIT(3)
 #define   ESPI_CTRL_PERIF_SW_RDY		BIT(1)
@@ -53,6 +56,7 @@
 #define ESPI_INT_STS		0x008
 #define   ESPI_INT_STS_HW_RST_DEASSERT		BIT(31)
 #define   ESPI_INT_STS_OOB_RX_TMOUT		BIT(23)
+#define   ESPI_VW_SYSEVT1			BIT(22)
 #define   ESPI_INT_STS_VW_SYSEVT1		BIT(22)
 #define   ESPI_INT_STS_FLASH_TX_ERR		BIT(21)
 #define   ESPI_INT_STS_OOB_TX_ERR		BIT(20)
@@ -67,6 +71,7 @@
 #define   ESPI_INT_STS_PERIF_NP_TX_ERR		BIT(11)
 #define   ESPI_INT_STS_PERIF_PC_TX_ERR		BIT(10)
 #define   ESPI_INT_STS_VW_GPIOEVT		BIT(9)
+#define   ESPI_VW_SYSEVT				BIT(8)
 #define   ESPI_INT_STS_VW_SYSEVT		BIT(8)
 #define   ESPI_INT_STS_FLASH_TX_CMPLT		BIT(7)
 #define   ESPI_INT_STS_FLASH_RX_CMPLT		BIT(6)
@@ -207,7 +212,9 @@
 #define   ESPI_SYSEVT1_SUSPEND_ACK		BIT(20)
 #define   ESPI_SYSEVT1_SUSPEND_WARN		BIT(0)
 #define ESPI_SYSEVT_INT_T0	0x110
+#define   ESPI_SYSEVT_INT_T0_MASK		0x00
 #define ESPI_SYSEVT_INT_T1	0x114
+#define   ESPI_SYSEVT_INT_T1_MASK		0x00
 #define ESPI_SYSEVT_INT_T2	0x118
 #define   ESPI_SYSEVT_INT_T2_HOST_RST_WARN	ESPI_SYSEVT_HOST_RST_WARN
 #define   ESPI_SYSEVT_INT_T2_OOB_RST_WARN	ESPI_SYSEVT_OOB_RST_WARN
@@ -222,8 +229,11 @@
 #define   ESPI_SYSEVT_INT_STS_S4_SLEEP		ESPI_SYSEVT_INT_S4_SLEEP
 #define   ESPI_SYSEVT_INT_STS_S3_SLEEP		ESPI_SYSEVT_INT_S3_SLEEP
 #define ESPI_SYSEVT1_INT_T0	0x120
+#define   ESPI_SYSEVT1_INT_T0_MASK		0x00
 #define ESPI_SYSEVT1_INT_T1	0x124
+#define   ESPI_SYSEVT1_INT_T1_MASK		0x00
 #define ESPI_SYSEVT1_INT_T2	0x128
+#define   ESPI_SYSEVT1_INT_T2_MASK		BIT(0)
 #define ESPI_SYSEVT1_INT_STS	0x12c
 #define   ESPI_SYSEVT1_INT_STS_SUSPEND_WARN	ESPI_SYSEVT1_SUSPEND_WARN
 #define ESPI_OOB_RX_DMA_RB_SIZE	0x130
@@ -274,6 +284,27 @@
 	 ESPI_INT_STS_FLASH_RX_CMPLT)
 
 /* collect ESPI_INT_EN bits of eSPI channels for convenience */
+#define ESPI_INT_MASK		\
+	(ESPI_HW_RESET	|	\
+	ESPI_VW_SYSEVT1	|	\
+	ESPI_VW_SYSEVT)
+/*
+ * Setup Interrupt Type / Enable of System Event from Master
+ *                                T2 T1 T0
+ *  1) HOST_RST_WARN : Dual Edge   1  0  0
+ *  2) OOB_RST_WARN  : Dual Edge   1  0  0
+ *  3) PLTRSTN       : Dual Edge   1  0  0
+ */
+#define ESPI_SYSEVT_INT_T2_MASK		\
+	(ESPI_SYSEVT_HOST_RST_WARN |	\
+	ESPI_SYSEVT_OOB_RST_WARN |	\
+	ESPI_SYSEVT_PLTRSTN |	\
+	ESPI_SYSEVT_SMI_OUT)
+
+#define ESPI_SYSEVT1_INT_MASK		\
+	(ESPI_SYSEVT1_INT_T0_MASK |	\
+	ESPI_SYSEVT1_INT_T1_MASK |	\
+	ESPI_SYSEVT1_INT_T2_MASK)
 #define ESPI_INT_EN_PERIF_BITS			\
 	(ESPI_INT_EN_PERIF_NP_TX_ABT |		\
 	 ESPI_INT_EN_PERIF_PC_TX_ABT |		\
diff -Naur linux_old/drivers/soc/aspeed/aspeed-espi-slave.c linux/drivers/soc/aspeed/aspeed-espi-slave.c
--- linux_old/drivers/soc/aspeed/aspeed-espi-slave.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/soc/aspeed/aspeed-espi-slave.c	2023-03-08 17:55:43.000000000 +0800
@@ -0,0 +1,607 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2015-2019, Intel Corporation.
+
+#include <linux/aspeed-espi-ioc.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/sched/signal.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+
+#include "aspeed-espi-ctrl.h"
+#include "aspeed-espi-oob.h"
+#include "aspeed-espi-vw.h"
+
+struct aspeed_espi {
+	struct regmap		*map;
+	struct clk		*clk;
+	struct device		*dev;
+	struct reset_control	*reset;
+	int			irq;
+	int			rst_irq;
+
+	/* for PLTRST_N signal monitoring interface */
+	struct miscdevice	pltrstn_miscdev;
+	/* for SMI Interrupt monitoring interface */
+	struct miscdevice	smi_miscdev;
+	spinlock_t		pltrstn_lock; /* for PLTRST_N signal sampling */
+	wait_queue_head_t	pltrstn_waitq;
+	char			pltrstn;
+	bool			pltrstn_in_avail;
+	spinlock_t		smi_lock; /* for SMI signal sampling */
+	wait_queue_head_t	smi_waitq;
+	char			smi;
+	bool			smi_is_avail;
+	struct aspeed_espi_ctrl *espi_ctrl;
+
+};
+
+static void aspeed_espi_sys_event(struct aspeed_espi *priv)
+{
+	u32 sts, evt;
+
+	regmap_read(priv->map, ESPI_SYSEVT_INT_STS, &sts);
+	regmap_read(priv->map, ESPI_SYSEVT, &evt);
+
+	dev_dbg(priv->dev, "sys: sts = %08x, evt = %08x\n", sts, evt);
+
+	if (!(evt & ESPI_SYSEVT_SLV_BOOT_STS)) {
+		regmap_write(priv->map, ESPI_SYSEVT,
+			     evt | ESPI_SYSEVT_SLV_BOOT_STS |
+			     ESPI_SYSEVT_SLV_BOOT_DONE);
+		dev_dbg(priv->dev, "Setting espi slave boot done\n");
+	}
+	if (sts & ESPI_SYSEVT_HOST_RST_WARN) {
+		if (evt & ESPI_SYSEVT_HOST_RST_WARN)
+			regmap_write_bits(priv->map, ESPI_SYSEVT,
+					  ESPI_SYSEVT_HOST_RST_ACK,
+					  ESPI_SYSEVT_HOST_RST_ACK);
+		else
+			regmap_write_bits(priv->map, ESPI_SYSEVT,
+					  ESPI_SYSEVT_HOST_RST_ACK, 0);
+		dev_dbg(priv->dev, "SYSEVT_HOST_RST_WARN: acked\n");
+	}
+	if (sts & ESPI_SYSEVT_OOB_RST_WARN) {
+		if (evt & ESPI_SYSEVT_OOB_RST_WARN)
+			regmap_write_bits(priv->map, ESPI_SYSEVT,
+					  ESPI_SYSEVT_OOB_RST_ACK,
+					  ESPI_SYSEVT_OOB_RST_ACK);
+		else
+			regmap_write_bits(priv->map, ESPI_SYSEVT,
+					  ESPI_SYSEVT_OOB_RST_ACK, 0);
+		dev_dbg(priv->dev, "SYSEVT_OOB_RST_WARN: acked\n");
+	}
+	if (sts & ESPI_SYSEVT_PLTRSTN || priv->pltrstn == 'U') {
+		spin_lock(&priv->pltrstn_lock);
+		priv->pltrstn = (evt & ESPI_SYSEVT_PLTRSTN) ? '1' : '0';
+		priv->pltrstn_in_avail = true;
+		spin_unlock(&priv->pltrstn_lock);
+		wake_up_interruptible(&priv->pltrstn_waitq);
+		dev_dbg(priv->dev, "SYSEVT_PLTRSTN: %c\n", priv->pltrstn);
+	}
+	if (sts & ESPI_SYSEVT_SMI_OUT || priv->smi == 'U') {
+		spin_lock(&priv->smi_lock);
+		priv->smi = (evt & ESPI_SYSEVT_SMI_OUT) ? '0' : '1';
+		priv->smi_is_avail = true;
+		spin_unlock(&priv->smi_lock);
+		wake_up_interruptible(&priv->smi_waitq);
+		dev_dbg(priv->dev, "SYSEVT_SMI: %c\n", priv->smi);
+	}
+
+	regmap_write(priv->map, ESPI_SYSEVT_INT_STS, sts);
+}
+
+static void aspeed_espi_sys_event1(struct aspeed_espi *priv)
+{
+	u32 sts, evt;
+
+	regmap_read(priv->map, ESPI_SYSEVT1_INT_STS, &sts);
+	regmap_read(priv->map, ESPI_SYSEVT1, &evt);
+
+	dev_dbg(priv->dev, "sys event1: sts = %08x, evt = %08x\n", sts, evt);
+
+	if (sts & ESPI_SYSEVT1_SUSPEND_WARN) {
+		if  (evt & ESPI_SYSEVT1_SUSPEND_WARN)
+			regmap_write_bits(priv->map, ESPI_SYSEVT1,
+					  ESPI_SYSEVT1_SUSPEND_ACK,
+					  ESPI_SYSEVT1_SUSPEND_ACK);
+		else
+			regmap_write_bits(priv->map, ESPI_SYSEVT1,
+					  ESPI_SYSEVT1_SUSPEND_ACK, 0);
+		dev_dbg(priv->dev, "SYSEVT1_SUS_WARN: acked\n");
+	}
+
+	regmap_write(priv->map, ESPI_SYSEVT1_INT_STS, sts);
+}
+
+static void aspeed_espi_boot_ack(struct aspeed_espi *priv)
+{
+	u32 evt;
+
+	regmap_read(priv->map, ESPI_SYSEVT, &evt);
+	if (!(evt & ESPI_SYSEVT_SLV_BOOT_STS)) {
+		regmap_write(priv->map, ESPI_SYSEVT,
+			     evt | ESPI_SYSEVT_SLV_BOOT_STS |
+			     ESPI_SYSEVT_SLV_BOOT_DONE);
+		dev_dbg(priv->dev, "Setting espi slave boot done\n");
+	}
+
+	regmap_read(priv->map, ESPI_SYSEVT1, &evt);
+	if (evt & ESPI_SYSEVT1_SUSPEND_WARN &&
+	    !(evt & ESPI_SYSEVT1_SUSPEND_ACK)) {
+		regmap_write(priv->map, ESPI_SYSEVT1,
+			     evt | ESPI_SYSEVT1_SUSPEND_ACK);
+		dev_dbg(priv->dev, "Boot SYSEVT1_SUS_WARN: acked\n");
+	}
+}
+
+static irqreturn_t aspeed_espi_irq(int irq, void *arg)
+{
+	struct aspeed_espi *priv = arg;
+	u32 sts, sts_handled = 0;
+
+	regmap_read(priv->map, ESPI_INT_STS, &sts);
+
+	dev_dbg(priv->dev, "INT_STS: 0x%08x\n", sts);
+
+	if (sts & ESPI_VW_SYSEVT) {
+		aspeed_espi_sys_event(priv);
+		sts_handled |= ESPI_VW_SYSEVT;
+	}
+	if (sts & ESPI_VW_SYSEVT1) {
+		aspeed_espi_sys_event1(priv);
+		sts_handled |= ESPI_VW_SYSEVT1;
+	}
+	if (sts & ESPI_INT_STS_OOB_BITS) {
+		aspeed_espi_oob_event(sts, priv->espi_ctrl->oob);
+		regmap_write(priv->map, ESPI_INT_STS, sts & ESPI_INT_STS_OOB_BITS);
+	}
+	if (sts & ESPI_HW_RESET) {
+		if (priv->rst_irq < 0) {
+			regmap_write_bits(priv->map, ESPI_CTRL,
+					  ESPI_CTRL_SW_RESET, 0);
+			regmap_write_bits(priv->map, ESPI_CTRL,
+					  ESPI_CTRL_SW_RESET,
+					  ESPI_CTRL_SW_RESET);
+		}
+
+		regmap_write_bits(priv->map, ESPI_CTRL,
+				  ESPI_CTRL_OOB_CHRDY,
+				  ESPI_CTRL_OOB_CHRDY);
+		aspeed_espi_boot_ack(priv);
+		sts_handled |= ESPI_HW_RESET;
+		aspeed_espi_oob_enable(priv->espi_ctrl->oob);
+		aspeed_espi_vw_enable(priv->espi_ctrl->vw);
+	}
+
+	regmap_write(priv->map, ESPI_INT_STS, sts);
+
+	return sts != sts_handled ? IRQ_NONE : IRQ_HANDLED;
+}
+
+static void aspeed_espi_config_irq(struct aspeed_espi *priv)
+{
+	regmap_write(priv->map, ESPI_SYSEVT_INT_T0, ESPI_SYSEVT_INT_T0_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT_INT_T1, ESPI_SYSEVT_INT_T1_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT_INT_T2, ESPI_SYSEVT_INT_T2_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT_INT_EN, 0xFFFFFFFF);
+	regmap_write(priv->map, ESPI_SYSEVT1_INT_T0, ESPI_SYSEVT1_INT_T0_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT1_INT_T1, ESPI_SYSEVT1_INT_T1_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT1_INT_T2, ESPI_SYSEVT1_INT_T2_MASK);
+	regmap_write(priv->map, ESPI_SYSEVT1_INT_EN, ESPI_SYSEVT1_INT_MASK);
+	regmap_write_bits(priv->map, ESPI_INT_EN, ESPI_INT_MASK,
+			  ESPI_INT_MASK);
+}
+
+static irqreturn_t aspeed_espi_reset_isr(int irq, void *arg)
+{
+	struct aspeed_espi *priv = arg;
+
+	reset_control_assert(priv->reset);
+	reset_control_deassert(priv->reset);
+
+	regmap_write_bits(priv->map, ESPI_CTRL,
+			  ESPI_CTRL_SW_RESET, 0);
+	regmap_write_bits(priv->map, ESPI_CTRL,
+			  ESPI_CTRL_SW_RESET, ESPI_CTRL_SW_RESET);
+
+	regmap_write_bits(priv->map, ESPI_CTRL,
+			  ESPI_CTRL_OOB_CHRDY, 0);
+
+	aspeed_espi_config_irq(priv);
+
+	return IRQ_HANDLED;
+}
+
+static inline struct aspeed_espi *to_aspeed_espi(struct file *filp)
+{
+	return container_of(filp->private_data, struct aspeed_espi,
+			    pltrstn_miscdev);
+}
+
+static inline struct aspeed_espi *to_aspeed_espi_smi(struct file *filp)
+{
+	return container_of(filp->private_data, struct aspeed_espi, smi_miscdev);
+}
+
+static int aspeed_espi_pltrstn_open(struct inode *inode, struct file *filp)
+{
+	struct aspeed_espi *priv = to_aspeed_espi(filp);
+
+	if ((filp->f_flags & O_ACCMODE) != O_RDONLY)
+		return -EACCES;
+	priv->pltrstn_in_avail = true ; /*Setting true returns first data after file open*/
+
+	return 0;
+}
+
+static int aspeed_espi_smi_open(struct inode *inode, struct file *filp)
+{
+	struct aspeed_espi *priv = to_aspeed_espi_smi(filp);
+
+	if ((filp->f_flags & O_ACCMODE) != O_RDONLY)
+		return -EACCES;
+	priv->smi_is_avail = true;
+
+	return 0;
+}
+
+static long aspeed_espi_smi_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct aspeed_espi *espi_smi = to_aspeed_espi_smi(fp);
+	u32 val = 0;
+
+	switch (cmd) {
+	case ASPEED_ESPI_SMI_GET:
+		regmap_read(espi_smi->map, ESPI_SYSEVT, &val);
+		if (put_user(val, (uint32_t __user *)arg))
+			return -EFAULT;
+		break;
+
+	default:
+		return -ENOTTY;
+	};
+
+	return 0;
+}
+
+static ssize_t aspeed_espi_pltrstn_read(struct file *filp, char __user *buf,
+					size_t count, loff_t *offset)
+{
+	struct aspeed_espi *priv = to_aspeed_espi(filp);
+	DECLARE_WAITQUEUE(wait, current);
+	char data, old_sample;
+	int ret = 0;
+
+	spin_lock_irq(&priv->pltrstn_lock);
+
+	if (filp->f_flags & O_NONBLOCK) {
+		if (!priv->pltrstn_in_avail) {
+			ret = -EAGAIN;
+			goto out_unlock;
+		}
+		data = priv->pltrstn;
+		priv->pltrstn_in_avail = false;
+	} else {
+		add_wait_queue(&priv->pltrstn_waitq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		old_sample = priv->pltrstn;
+
+		do {
+			if (old_sample != priv->pltrstn) {
+				data = priv->pltrstn;
+				priv->pltrstn_in_avail = false;
+				break;
+			}
+
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+			} else {
+				spin_unlock_irq(&priv->pltrstn_lock);
+				schedule();
+				spin_lock_irq(&priv->pltrstn_lock);
+			}
+		} while (!ret);
+
+		remove_wait_queue(&priv->pltrstn_waitq, &wait);
+		set_current_state(TASK_RUNNING);
+	}
+out_unlock:
+	spin_unlock_irq(&priv->pltrstn_lock);
+
+	if (ret)
+		return ret;
+
+	ret = put_user(data, buf);
+	if (!ret)
+		ret = sizeof(data);
+
+	return ret;
+}
+
+static ssize_t aspeed_espi_smi_read(struct file *filp, char __user *buf,
+				    size_t count, loff_t *offset)
+{
+	struct aspeed_espi *priv = to_aspeed_espi_smi(filp);
+	DECLARE_WAITQUEUE(wait, current);
+	char data, old_sample;
+	int ret = 0;
+
+	spin_lock_irq(&priv->smi_lock);
+
+	if (filp->f_flags & O_NONBLOCK) {
+		if (!priv->smi_is_avail) {
+			ret = -EAGAIN;
+			goto out_unlock;
+		}
+		data = priv->smi;
+		priv->smi_is_avail = false;
+	} else {
+		add_wait_queue(&priv->smi_waitq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		old_sample = priv->smi;
+
+		do {
+			if (old_sample != priv->smi) {
+				data = priv->smi;
+				priv->smi_is_avail = false;
+				break;
+			}
+
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+			} else {
+				spin_unlock_irq(&priv->smi_lock);
+				schedule();
+				spin_lock_irq(&priv->smi_lock);
+			}
+		} while (!ret);
+
+		remove_wait_queue(&priv->smi_waitq, &wait);
+		set_current_state(TASK_RUNNING);
+	}
+out_unlock:
+	spin_unlock_irq(&priv->smi_lock);
+
+	if (ret)
+		return ret;
+
+	ret = put_user(data, buf);
+	if (ret)
+		return ret;
+
+	return sizeof(data);
+}
+
+static unsigned int aspeed_espi_pltrstn_poll(struct file *file,
+						 poll_table *wait)
+{
+	struct aspeed_espi *priv = to_aspeed_espi(file);
+	unsigned int mask = 0;
+
+	poll_wait(file, &priv->pltrstn_waitq, wait);
+	if (priv->pltrstn_in_avail)
+		mask |= POLLIN;
+	return mask;
+}
+
+static unsigned int aspeed_espi_smi_poll(struct file *file, poll_table *wait)
+{
+	struct aspeed_espi *priv = to_aspeed_espi_smi(file);
+	unsigned int mask = 0;
+
+	poll_wait(file, &priv->smi_waitq, wait);
+
+	if (priv->smi_is_avail)
+		mask |= POLLIN;
+	return mask;
+}
+
+static const struct file_operations aspeed_espi_pltrstn_fops = {
+	.owner	= THIS_MODULE,
+	.open	= aspeed_espi_pltrstn_open,
+	.read	= aspeed_espi_pltrstn_read,
+	.poll	= aspeed_espi_pltrstn_poll,
+};
+
+static const struct file_operations aspeed_espi_smi_fops = {
+	.owner	= THIS_MODULE,
+	.open	= aspeed_espi_smi_open,
+	.read	= aspeed_espi_smi_read,
+	.poll	= aspeed_espi_smi_poll,
+	.unlocked_ioctl = aspeed_espi_smi_ioctl,
+};
+
+static const struct regmap_config aspeed_espi_regmap_cfg = {
+	.reg_bits	= 32,
+	.reg_stride	= 4,
+	.val_bits	= 32,
+	.max_register	= 0x200,
+};
+
+static int aspeed_espi_probe(struct platform_device *pdev)
+{
+	struct aspeed_espi_ctrl *espi_ctrl;
+	struct aspeed_espi *priv;
+	struct resource *res;
+	void __iomem *regs;
+	u32 ctrl;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	espi_ctrl = devm_kzalloc(&pdev->dev, sizeof(*espi_ctrl), GFP_KERNEL);
+	if (!espi_ctrl)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, priv);
+	priv->dev = &pdev->dev;
+	priv->espi_ctrl = espi_ctrl;
+	espi_ctrl->model = of_device_get_match_data(&pdev->dev);
+	priv->map = devm_regmap_init_mmio(&pdev->dev, regs,
+					  &aspeed_espi_regmap_cfg);
+	if (IS_ERR(priv->map))
+		return PTR_ERR(priv->map);
+	espi_ctrl->map = priv->map;
+	aspeed_espi_config_irq(priv);
+	espi_ctrl->oob = aspeed_espi_oob_alloc(&pdev->dev, espi_ctrl);
+	if (IS_ERR(espi_ctrl->oob)) {
+		dev_err(&pdev->dev, "Failed to allocate espi out-of-band channel\n");
+		return PTR_ERR(espi_ctrl->oob);
+	}
+	espi_ctrl->vw = aspeed_espi_vw_alloc(&pdev->dev, espi_ctrl);
+	if (IS_ERR(espi_ctrl->vw)) {
+		dev_err(&pdev->dev, "Failed to allocate espi virtual wire channel\n");
+		return PTR_ERR(espi_ctrl->vw);
+	}
+
+	spin_lock_init(&priv->pltrstn_lock);
+	spin_lock_init(&priv->smi_lock);
+	init_waitqueue_head(&priv->pltrstn_waitq);
+	init_waitqueue_head(&priv->smi_waitq);
+	priv->pltrstn = 'U'; /* means it's not reported yet from master */
+	priv->smi = 'U';
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0)
+		return priv->irq;
+
+	ret = devm_request_irq(&pdev->dev, priv->irq, aspeed_espi_irq, 0,
+			       "aspeed-espi-irq", priv);
+	if (ret)
+		return ret;
+
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "aspeed,ast2600-espi-slave")) {
+		priv->rst_irq = platform_get_irq(pdev, 1);
+		if (priv->rst_irq < 0)
+			return priv->rst_irq;
+
+		ret = devm_request_irq(&pdev->dev, priv->rst_irq,
+				       aspeed_espi_reset_isr, 0,
+				       "aspeed-espi-rst-irq", priv);
+		if (ret)
+			return ret;
+
+		priv->reset = devm_reset_control_get(&pdev->dev, NULL);
+		if (IS_ERR(priv->reset))
+			return PTR_ERR(priv->reset);
+	} else {
+		priv->rst_irq = -ENOTSUPP;
+	}
+
+	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk)){
+        dev_err(&pdev->dev, "couldn't get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "couldn't enable clock\n");
+		return ret;
+	}
+
+	/*
+	 * We check that the regmap works on this very first access, but as this
+	 * is an MMIO-backed regmap, subsequent regmap access is not going to
+	 * fail and we skip error checks from this point.
+	 */
+	ret = regmap_read(priv->map, ESPI_CTRL, &ctrl);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read ctrl register\n");
+		goto err_clk_disable_out;
+	}
+	regmap_write(priv->map, ESPI_CTRL,
+		     ctrl | ESPI_CTRL_OOB_CHRDY);
+
+	priv->pltrstn_miscdev.minor = MISC_DYNAMIC_MINOR;
+	priv->pltrstn_miscdev.name = "espi-pltrstn";
+	priv->pltrstn_miscdev.fops = &aspeed_espi_pltrstn_fops;
+	priv->pltrstn_miscdev.parent = &pdev->dev;
+
+	priv->smi_miscdev.minor = MISC_DYNAMIC_MINOR - 1;
+	priv->smi_miscdev.name = "espi-smi";
+	priv->smi_miscdev.fops = &aspeed_espi_smi_fops;
+	priv->smi_miscdev.parent = &pdev->dev;
+
+	ret = misc_register(&priv->pltrstn_miscdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to register device\n");
+		goto err_clk_disable_out;
+	}
+
+	ret = misc_register(&priv->smi_miscdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to register SMI device\n");
+		goto err_clk_disable_out;
+	}
+
+	aspeed_espi_boot_ack(priv);
+
+	dev_info(&pdev->dev, "eSPI registered, irq %d\n", priv->irq);
+
+	return 0;
+
+err_clk_disable_out:
+	clk_disable_unprepare(priv->clk);
+	return ret;
+}
+
+static int aspeed_espi_remove(struct platform_device *pdev)
+{
+	struct aspeed_espi *priv = dev_get_drvdata(&pdev->dev);
+
+	aspeed_espi_oob_free(priv->dev, priv->espi_ctrl->oob);
+	aspeed_espi_vw_free(priv->dev, priv->espi_ctrl->vw);
+	misc_deregister(&priv->pltrstn_miscdev);
+	misc_deregister(&priv->smi_miscdev);
+	clk_disable_unprepare(priv->clk);
+	return 0;
+}
+
+static const struct aspeed_espi_model ast2600_model = {
+	.version = ESPI_AST2600,
+};
+
+static const struct of_device_id of_espi_match_table[] = {
+	{ .compatible = "aspeed,ast2500-espi-slave" },
+	{ .compatible = "aspeed,ast2600-espi-slave",
+	  .data	      = &ast2600_model},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, of_espi_match_table);
+
+static struct platform_driver aspeed_espi_driver = {
+	.driver	= {
+		.name		= KBUILD_MODNAME,
+		.of_match_table	= of_match_ptr(of_espi_match_table),
+	},
+	.probe	= aspeed_espi_probe,
+	.remove	= aspeed_espi_remove,
+};
+module_platform_driver(aspeed_espi_driver);
+
+MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
+MODULE_AUTHOR("Jae Hyun Yoo <jae.hyun.yoo@linux.intel.com>");
+MODULE_DESCRIPTION("Aspeed eSPI driver");
+MODULE_LICENSE("GPL v2");
diff -Naur linux_old/drivers/soc/aspeed/Makefile linux/drivers/soc/aspeed/Makefile
--- linux_old/drivers/soc/aspeed/Makefile	2023-03-09 17:30:45.169942000 +0800
+++ linux/drivers/soc/aspeed/Makefile	2023-03-09 21:19:00.000000000 +0800
@@ -14,8 +13,8 @@
 obj-$(CONFIG_ASPEED_SOCINFO)		+= aspeed-socinfo.o
 obj-$(CONFIG_ASPEED_SBC)		+= aspeed-sbc.o
 obj-$(CONFIG_ASPEED_XDMA)		+= aspeed-xdma.o
-obj-$(CONFIG_ASPEED_ESPI)		+= aspeed-espi-ctrl.o \
-					   aspeed-espi-perif.o \
+obj-$(CONFIG_ASPEED_ESPI)		+=aspeed-espi-perif.o \
 					   aspeed-espi-vw.o \
 					   aspeed-espi-oob.o \
-					   aspeed-espi-flash.o
+					   aspeed-espi-flash.o\
+             aspeed-espi-slave.o
diff -Naur linux_old/include/linux/aspeed-espi-ioc.h linux/include/linux/aspeed-espi-ioc.h
--- linux_old/include/linux/aspeed-espi-ioc.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/linux/aspeed-espi-ioc.h	2022-12-22 15:45:33.255118000 +0800
@@ -0,0 +1,205 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 Aspeed Technology Inc.
+ */
+#ifndef _ASPEED_ESPI_IOC_H
+#define _ASPEED_ESPI_IOC_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/*
+ * eSPI cycle type encoding
+ *
+ * Section 5.1 Cycle Types and Packet Format,
+ * Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ */
+#define ESPI_PERIF_MEMRD32		0x00
+#define ESPI_PERIF_MEMRD64		0x02
+#define ESPI_PERIF_MEMWR32		0x01
+#define ESPI_PERIF_MEMWR64		0x03
+#define ESPI_PERIF_MSG			0x10
+#define ESPI_PERIF_MSG_D		0x11
+#define ESPI_PERIF_SUC_CMPLT		0x06
+#define ESPI_PERIF_SUC_CMPLT_D_MIDDLE	0x09
+#define ESPI_PERIF_SUC_CMPLT_D_FIRST	0x0b
+#define ESPI_PERIF_SUC_CMPLT_D_LAST	0x0d
+#define ESPI_PERIF_SUC_CMPLT_D_ONLY	0x0f
+#define ESPI_PERIF_UNSUC_CMPLT		0x0c
+#define ESPI_OOB_MSG			0x21
+#define ESPI_FLASH_READ			0x00
+#define ESPI_FLASH_WRITE		0x01
+#define ESPI_FLASH_ERASE		0x02
+#define ESPI_FLASH_SUC_CMPLT		0x06
+#define ESPI_FLASH_SUC_CMPLT_D_MIDDLE	0x09
+#define ESPI_FLASH_SUC_CMPLT_D_FIRST	0x0b
+#define ESPI_FLASH_SUC_CMPLT_D_LAST	0x0d
+#define ESPI_FLASH_SUC_CMPLT_D_ONLY	0x0f
+#define ESPI_FLASH_UNSUC_CMPLT		0x0c
+
+/*
+ * eSPI packet format structure
+ *
+ * Section 5.1 Cycle Types and Packet Format,
+ * Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ */
+struct espi_comm_hdr {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+} __packed;
+
+struct espi_perif_mem32 {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u32 addr_be;
+	u8 data[];
+} __packed;
+
+struct espi_perif_mem64 {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u32 addr_be;
+	u8 data[];
+} __packed;
+
+struct espi_perif_msg {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u8 msg_code;
+	u8 msg_byte[4];
+	u8 data[];
+} __packed;
+
+struct espi_perif_cmplt {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u8 data[];
+} __packed;
+
+struct espi_oob_msg {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u8 data[];
+} __packed;
+
+struct espi_flash_rwe {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u32 addr_be;
+	u8 data[];
+} __packed;
+
+struct espi_flash_cmplt {
+	u8 cyc;
+	u8 len_h : 4;
+	u8 tag : 4;
+	u8 len_l;
+	u8 data[];
+} __packed;
+
+struct aspeed_espi_ioc {
+	u32 pkt_len;
+	u8 *pkt;
+};
+
+#define ESPI_LEN_HIGH(len)	(((len) >> 0x08) & 0x0F)
+#define ESPI_LEN_LOW(len)	((len) & 0xFF)
+#define ESPI_LEN(len_h, len_l)	((((len_h) << 0x08) & 0x0F00) | ((len_l) & 0xFF))
+
+/*
+ * We choose the longest header and the max payload size based on the Intel
+ * specification to define the maximum eSPI packet length.
+ */
+#define ASPEED_ESPI_PLD_LEN_MIN	BIT(6)
+#define ASPEED_ESPI_PLD_LEN_MAX	BIT(12)
+#define ASPEED_ESPI_PKT_LEN_MAX	(sizeof(struct espi_perif_msg) + ASPEED_ESPI_PLD_LEN_MAX)
+
+#define __ASPEED_ESPI_IOCTL_MAGIC	0xb8
+
+/*
+ * The IOCTL-based interface works in the eSPI packet in/out paradigm.
+ *
+ * Only the virtual wire IOCTL is a special case which does not send
+ * or receive an eSPI packet. However, to keep a more consisten use from
+ * userspace, we make all of the four channel drivers serve through the
+ * IOCTL interface.
+ *
+ * For the eSPI packet format, refer to
+ *   Section 5.1 Cycle Types and Packet Format,
+ *   Intel eSPI Interface Base Specification, Rev 1.0, Jan. 2016.
+ *
+ * For the example user apps using these IOCTL, refer to
+ *   https://github.com/AspeedTech-BMC/aspeed_app/tree/master/espi_test
+ */
+
+/*
+ * Peripheral Channel (CH0)
+ *  - ASPEED_ESPI_PERIF_PC_GET_RX
+ *      Receive an eSPI Posted/Completion packet
+ *  - ASPEED_ESPI_PERIF_PC_PUT_TX
+ *      Transmit an eSPI Posted/Completion packet
+ *  - ASPEED_ESPI_PERIF_NP_PUT_TX
+ *      Transmit an eSPI Non-Posted packet
+ */
+#define ASPEED_ESPI_PERIF_PC_GET_RX	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x00, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_PERIF_PC_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x01, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_PERIF_NP_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x02, struct aspeed_espi_ioc)
+/*
+ * Virtual Wire Channel (CH1)
+ *  - ASPEED_ESPI_VW_GET_GPIO_VAL
+ *      Read the input value of GPIO over the VW channel
+ *  - ASPEED_ESPI_VW_PUT_GPIO_VAL
+ *      Write the output value of GPIO over the VW channel
+ */
+#define ASPEED_ESPI_VW_GET_GPIO_VAL	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x10, u8)
+#define ASPEED_ESPI_VW_PUT_GPIO_VAL	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x11, u8)
+/*
+ * Out-of-band Channel (CH2)
+ *  - ASPEED_ESPI_OOB_GET_RX
+ *      Receive an eSPI OOB packet
+ *  - ASPEED_ESPI_OOB_PUT_TX
+ *      Transmit an eSPI OOB packet
+ */
+#define ASPEED_ESPI_OOB_GET_RX		_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x20, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_OOB_PUT_TX		_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x21, struct aspeed_espi_ioc)
+/*
+ * Flash Channel (CH3)
+ *  - ASPEED_ESPI_FLASH_GET_RX
+ *      Receive an eSPI flash packet
+ *  - ASPEED_ESPI_FLASH_PUT_TX
+ *      Transmit an eSPI flash packet
+ */
+#define ASPEED_ESPI_FLASH_GET_RX	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x30, struct aspeed_espi_ioc)
+#define ASPEED_ESPI_FLASH_PUT_TX	_IOW(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x31, struct aspeed_espi_ioc)
+/*
+ * eSPI SMI OUT
+ *  - ASPEED_ESPI_SMI_GET
+ *      Receive an eSPI status of SMI Out(Bit 9)
+ */
+#define ASPEED_ESPI_SMI_GET	_IOR(__ASPEED_ESPI_IOCTL_MAGIC, \
+					     0x40, struct aspeed_espi_ioc)
+
+#endif
